## 編譯器理論

 JavaScript 被歸類為直譯式語言，但某種程度上表現得卻像是編譯式語言。跟傳統的編譯語言不同的地方是，無法事先就編譯好、編譯出來的東西也無法在各個系統移植，不過卻會執行一些傳統語言也會執行的步驟 :

* Tokenizing ( 語法基本單元化 ) 與 Lexing ( 語彙分析 )

    將字元拆解成對該語言有意義的組塊，這些組塊稱作語法基本單元。像 `var a = 2;` 可能被拆成 `var` 、 `a` 、 `=` 、 `2` 。

* Parsing ( 剖析 )

    將語法基本單元轉換成樹狀結構 AST ( Abstract syntax tree )。

* Code-Generation ( 產生程式碼 )

    接受 AST 並將其轉換成可執行程式碼。這部分隨語言、平台有大幅度的不同。

JavaScript 做的事情比這三步驟複雜一些，在 Code-Generation ( 產生機器可以懂得代碼 ) 過程，會有最佳化的步驟來消除多餘的元素。如果要更加了解 JavaScript 底部的編譯過程，可以查詢 JIT ( Just In Time Compiler )。

> 這段討論或許有些過於學術，不過個人猜測各種 JavaScript Framework 之所以可以將 ES6 的語法運行在舊的瀏覽器上，原因在於只要嘗試產出相同的 AST 餵給瀏覽器，就能夠產出相容於舊版瀏覽器的程式碼。

### LHS(lefthand-side) 和 RHS(righthand-side)

LHS 和 RHS 分別是作者給予的稱呼，是一種程式查找變數值的概念 :

``` JavaScript
a = 1;
var b = a;
```

第一行進行了 LHS，JavaScript 引擎會從當前的 Scope ( 用 `var` 宣告會以 function 來劃分 Scope，而 `let` 則是單純的有 `{}` 就會劃分 Scope ) 找尋變數 `a` 的 Reference，並把 1 這個值賦予給它，當在這個 Scope 找不到變數的 Reference，它會往外面的 Scope 繼續找尋，如果還是沒有找到，JS 引擎會替它創造出一個變數 ( 如果是在嚴格模式，就會丟出 `ReferenceError` )。

第二行則是兩者都會進行，先不論對於 `b` 的 LHS，在等式的右邊進行了 RHS，它會去找尋變數 `a` 中存放的值，假設在相同的 scope 中沒有找到，它會繼續往外層的 scope 繼續尋找，然而最後若還是沒找到，它會丟出 `ReferenceError` 。

注意在非嚴格模式下，這兩者表現並不相同，雖然都像找尋未宣告的變數，但根本上有些不同。

``` JavaScript
function foo(a) {
    var b = a;
    return b + a;
}

var c = foo(2);
```

在上面這段程式碼中，總共有三個 LHS、四個 RHS :

* LHS : 

`c = ..;` 、 `a = 2` 、 `b = ..`

* RHS :

`foo(2..` 、 ` = a;` 、 `a..` 、 `..b`

## 語彙範疇 ( Lexical Scope )

JavaScript 多數時候是用語彙範疇來進行查找，就像前面提到的，當變數在當下的 Scope 找不到值時，會往外尋找直到找到為止，然而這會造成遮蔽 ( shadow ) 現象，外層的變數如果取名與內層的相同，就沒有辦法拿到 ( 全域變數是可以使用 window 來取得 )。

### 修改語彙範疇

JavaScript 有幾種方法可以修改語彙範疇，然而會導致較差的效能，原因在編譯時決定好的語彙範疇會被打亂，多數時候沒有這樣使用的理由。

#### eval

`eval(..)` 可接受字串當作參數，並將字串的內容視為當下編寫好的程式碼 :

``` JavaScript
function foo(str, a) {
    eval(str);
    console.log(a, b);
}
var b = 2;
foo("var b = 3;", 1); // 1, 3
```

因為 `eval(..)` 的存在，而遮蔽了外面的 `var b = 2;` 。不過在嚴格模式下， `eval(..)` 只會影響自己的範疇 :

``` JavaScript
function foo(str) {
    "use strict";
    eval(str);
    console.log(a); // ReferenceError
}
foo("var a = 2;");
```

另外 `setTimeout(..)` 、 `setInterval(..)` 、 `new Function(..)` 有相同效果的寫法 ( 可以查詢 MDN 網站，裡面有幾種建構方式作法就跟 `eval(..)` 有相同效果 )，它們也可接受字串當作參數動態產生成程式碼，因此也避免使用。

> https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout

#### with

`with` 是另一個修改語彙範疇的作法 ( 已經被棄用，在 JavaScript 的嚴格模式是不能用 ) :

``` JavaScript
var obj = {
    a: 1,
    b: 2,
    c: 3
}

obj.a = 2;
obj.b = 3;
obj.c = 4;

with(obj) {
    a = 3;
    b = 4;
    c = 5;
    //d = 5;
}

// console.log(d);
```

`with(..)` 看似提供了更簡潔的寫法，然而實際上會發生全域值外洩的問題。它的運作行為跟 LHS 類似，首先在 `obj` 自己的 scope 裡面進行查找，如果沒有會繼續往外查詢，當到了全域還是沒有找到，此時就會創造一個變數。

### 語彙範疇的優點

* 最小權限原則 & 避免命名衝突

``` JavaScript
function doSomething(a) {
    function doSomethingElse(a) {
        return a - 1;
    }
    ......
}
```

* 命名空間的模組管理

``` JavaScript
var a = {
    s1: "s1",
    s2: function() {
        ...
    },
    s3: function() {
        ...
    }
}
```

另一個 ES6 的模組是 `module` ，雖然是個新語法，但運作還是依靠範疇理論。

* 垃圾回收機制

``` JavaScript
function process(data) {
    ..
}

var someReallyBigData = {
    ..
};
process(someReallyBigData);
/*
{
    let someReallyBigData = {
        ..
    };
    process(someReallyBigData);
}
*/
document.getElementById("test").addEventListener("click", function() {
    console.log("test");
})
```

在這段程式碼中， `someReallyBigData` 在執行完 `process` 後就可以回收了，然而因為 `clickEvent` 的存在有閉包，它可能不會被回收 ( 還是要端看瀏覽器怎麼實作 )，此時使用 `let` 並將其包起來，就可以比較好的觸發垃圾回收機制。

### 其他與語彙範疇相關的特點

* 只要開頭不是 function 就是函式運算式，最常見的就是下面的IIFE :

``` JavaScript
(function foo() {
    var a = 3;
    console.log(a);
})();
```

* try/catch 的 catch 語句中，其實會幫忙切割出 scope :

``` JavaScript
try {
    undefined();
} catch (err) {
    console.log(err);
}
console.log(err); // ReferenceError
```

* 函式運算式就算具有名字，還是無法直接在它當下的 scope 進行調用，只能在 function 內自行呼叫。

``` JavaScript
var foo = function bar() {
    //
}
bar(); //ReferenceError
```

## Hoisting 

* 並不是當純的拉到全域，而是依照 scope 來 Hoisting :

``` JavaScript
function foo() {
    console.log(a); // undefined

    var a = 2;
}
foo();
```

* `var` 和 `function` 命名有所衝突時，會以 `function` 為 Hoisting 的優先。

## 閉包

閉包是函式記得並存取其語彙範疇的能力，甚至當函式在語彙範疇外執行時也是如此。從純學術的觀點來看，這樣的程式碼也帶有閉包 :

``` JavaScript
function foo() {
    var a = 2;

    function bar() {
        console.log(a);
    }
    bar();
}
foo();
```

* 只要把函式當成一級函式到處傳遞，基本上就很有可能看到閉包，不論是 `setTimeout(..)` 、 `Ajax` 、 `EventHandler` ，這些都有可能出現閉包，閉包幾乎無處不在。

* 學術上來看，閉包是發生在宣告時期，只是沒有辦法直接觀測，最常見的就是 IIFE。

## 模組

* 命名空間

``` JavaScript
function CoolModule() {
    var something = "cool";
    var another = [1, 2, 3];

    function doSomething() {
        console.log(something);
    }

    function doAnother() {
        console.log(another.join(" ! "));
    }

    return {
        doSomething: doSomething,
        doAnother: doAnother
    };
}

var foo = CoolModule();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

這段程式碼其實跟前面的命名空間相當類似，差別在 `return` 的敘述只有 `function` 的名稱而已。要使用模組模式，有兩個必要條件 :

1. 必須要有一個外層的包含函式，並且必須至少呼叫一次。
2. 至少回傳一個內層函式，讓內層函式包含私有的 scope，並依靠其他 function 更動裡面的內容。

* 利用命名空間完成模組

``` JavaScript
var MyModules = (function Manager() {
    var modules = {};

    function define(name, deps, impl) {
        for (var i = 0; i < deps.length; i++) {
            deps[i] = modules[deps[i]];
        }
        modules[name] = impl.apply(impl, deps);
    }

    function get(name) {
        return modules[name];
    }

    return {
        define: define,
        get: get
    };
})();
```

``` JavaScript
MyModules.define("bar", [], function() {
    function hello(who) {
        return "Let me introduce: " + who;
    }

    return {
        hello: hello
    };
});

MyModules.define("foo", ["bar"], function(bar) {
    var hungry = "hippo";

    function awesome() {
        console.log(bar.hello(hungry).toUpperCase());
    }

    return {
        awesome: awesome
    };
});

var bar = MyModules.get("bar");
var foo = MyModules.get("foo");

console.log(
    bar.hello("hippo")
); // Let me introduce: hippo

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

* ES6模組

下面展示 ES6 的模組寫法，可以看到將想輸出的屬性放在 `export` 語法後面，模組的檔案內容則像是閉包一樣。

bar.js :

``` JavaScript
function hello(who) {
    return "Let me introduce: " + who;
}

export hello;
```

foo.js :

``` JavaScript
import hello from "bar";

var hungry = "hippo";

function awesome() {
    console.log(
        hello(hungry).toUpperCase()
    );
}

export awesome;
```

baz.js :

``` JavaScript
module foo from "foo";
module bar from "bar";

console.log(
    bar.hello("rhino")
); // Let me introduce: rhino

foo.awesome(); // LET ME INTRODUCE: HIPPO
```
